<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üé§ N'oubliez pas les Paroles</title>
<link href="https://fonts.googleapis.com/css2?family=Dela+Gothic+One&family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-dark: #0a0a1a;
    --bg-card: #12122a;
    --accent: #f7b731;
    --accent-glow: #f7b73166;
    --pink: #e84393;
    --pink-glow: #e8439366;
    --blue: #00cec9;
    --blue-glow: #00cec966;
    --text: #f0f0f0;
    --text-dim: #8888aa;
    --success: #00b894;
    --danger: #d63031;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg-dark);
    color: var(--text);
    font-family: 'Nunito', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  body::before {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: 
      radial-gradient(ellipse at 20% 50%, #1a0a3a 0%, transparent 50%),
      radial-gradient(ellipse at 80% 20%, #0a1a3a 0%, transparent 50%),
      radial-gradient(ellipse at 50% 80%, #1a0a2a 0%, transparent 50%);
    z-index: -1;
  }

  .app {
    max-width: 960px;
    margin: 0 auto;
    padding: 20px;
  }

  /* ---- Header ---- */
  .header {
    text-align: center;
    padding: 24px 0 16px;
  }

  .header h1 {
    font-family: 'Dela Gothic One', cursive;
    font-size: 2rem;
    background: linear-gradient(135deg, var(--accent), var(--pink));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    filter: drop-shadow(0 0 20px var(--accent-glow));
  }

  .header p {
    color: var(--text-dim);
    margin-top: 4px;
    font-size: 0.9rem;
  }

  /* ---- Video Stage ---- */
  .video-stage {
    position: relative;
    border-radius: 16px;
    overflow: hidden;
    background: #000;
    aspect-ratio: 16 / 9;
    margin: 20px 0 8px;
    border: 2px solid #222244;
    box-shadow: 0 0 40px rgba(0,0,0,0.5), 0 0 60px var(--accent-glow);
  }

  .video-stage video {
    width: 100%;
    height: 100%;
    object-fit: contain;
    display: block;
  }

  .video-stage .placeholder {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    background: linear-gradient(135deg, #0a0a2a, #1a0a3a);
  }

  .placeholder .icon { font-size: 4rem; opacity: 0.3; }
  .placeholder .msg { color: var(--text-dim); font-size: 0.95rem; }

  /* Subtitle overlay */
  .subtitle-overlay {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    padding: 20px 30px 24px;
    background: linear-gradient(transparent, rgba(0,0,0,0.88));
    text-align: center;
    min-height: 80px;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    pointer-events: none;
  }

  .subtitle-text {
    font-size: 1.5rem;
    font-weight: 800;
    line-height: 1.6;
    text-shadow: 0 2px 8px rgba(0,0,0,0.9);
  }

  .subtitle-text .word {
    display: inline-block;
    margin: 0 3px;
    padding: 2px 4px;
    border-radius: 4px;
    transition: all 0.25s;
  }

  .word.highlighted { color: var(--accent); transform: scale(1.08); }

  .word.hidden-word {
    background: rgba(255,255,255,0.13);
    color: transparent;
    border-radius: 6px;
    min-width: 50px;
    position: relative;
  }
  .word.hidden-word::after {
    content: '____';
    color: var(--text-dim);
    position: absolute;
    left: 50%; top: 50%;
    transform: translate(-50%, -50%);
    font-size: 0.9rem;
    letter-spacing: 2px;
  }

  .word.revealed {
    background: rgba(0, 184, 148, 0.3);
    color: var(--success);
    animation: revealPop 0.4s ease;
  }

  .word.revealed-static {
    background: rgba(0, 184, 148, 0.25);
    color: var(--success);
  }

  .word.backing-vocal {
    color: var(--text-dim);
    opacity: 0.6;
    font-style: italic;
  }

  /* ---- Sound mode option ---- */
  .sound-mode-option {
    padding: 6px 12px;
    text-align: center;
  }

  .sound-mode-label {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    font-size: 0.82rem;
    color: var(--text-dim);
    user-select: none;
    transition: color 0.2s;
  }
  .sound-mode-label:hover { color: var(--text); }

  .sound-mode-label input[type="checkbox"] {
    width: 16px;
    height: 16px;
    accent-color: var(--accent);
    cursor: pointer;
  }

  @keyframes revealPop {
    0% { transform: scale(1.4); }
    50% { transform: scale(0.9); }
    100% { transform: scale(1); }
  }

  /* Status badges */
  .status-bar {
    position: absolute;
    top: 14px; right: 14px;
    display: flex; gap: 8px;
  }

  .status-pill {
    padding: 5px 12px;
    border-radius: 20px;
    font-size: 0.72rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    backdrop-filter: blur(10px);
  }

  .status-pill.playing { background: rgba(247,183,49,0.25); color: var(--accent); border: 1px solid var(--accent); }
  .status-pill.muted { background: rgba(214,48,49,0.25); color: var(--danger); border: 1px solid var(--danger); animation: pulse 1s infinite; }
  .status-pill.paused { background: rgba(136,136,170,0.25); color: var(--text-dim); border: 1px solid #555; }

  @keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:0.5; } }

  /* Score */
  .score-display {
    position: absolute;
    top: 14px; left: 14px;
    backdrop-filter: blur(10px);
    background: rgba(0,0,0,0.5);
    padding: 6px 14px;
    border-radius: 12px;
    border: 1px solid #333;
  }
  .score-display .label { font-size: 0.6rem; text-transform: uppercase; letter-spacing: 2px; color: var(--text-dim); }
  .score-display .value { font-family: 'Dela Gothic One', cursive; font-size: 1.4rem; color: var(--accent); }

  /* ---- Progress ---- */
  .progress-container {
    background: #1a1a3a;
    border-radius: 8px;
    height: 6px;
    margin: 8px 0;
    overflow: visible;
    position: relative;
    cursor: pointer;
  }

  .progress-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--pink));
    border-radius: 8px;
    transition: width 0.15s linear;
  }

  .cutoff-marker {
    position: absolute;
    top: -5px;
    width: 3px;
    height: 16px;
    background: var(--danger);
    border-radius: 2px;
    box-shadow: 0 0 8px var(--danger);
    z-index: 2;
  }

  .time-display {
    display: flex;
    justify-content: space-between;
    font-size: 0.78rem;
    color: var(--text-dim);
    margin-bottom: 12px;
    font-variant-numeric: tabular-nums;
  }

  /* ---- Controls ---- */
  .controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
    margin: 12px 0;
  }

  .btn {
    padding: 11px 24px;
    border: none;
    border-radius: 12px;
    font-family: 'Nunito', sans-serif;
    font-weight: 700;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 7px;
  }
  .btn:hover { transform: translateY(-2px); }
  .btn:active { transform: translateY(0); }
  .btn:disabled { opacity: 0.35; cursor: not-allowed; transform: none; }

  .btn-primary { background: linear-gradient(135deg, var(--accent), #e0a020); color: #1a1a1a; box-shadow: 0 4px 12px var(--accent-glow); }
  .btn-secondary { background: var(--bg-card); color: var(--text); border: 1px solid #333; }
  .btn-danger { background: linear-gradient(135deg, var(--pink), #c0392b); color: white; box-shadow: 0 4px 12px var(--pink-glow); }
  .btn-success { background: linear-gradient(135deg, var(--blue), var(--success)); color: #1a1a1a; box-shadow: 0 4px 12px var(--blue-glow); }
  .btn-warning { background: linear-gradient(135deg, #f39c12, #e67e22); color: #1a1a1a; box-shadow: 0 4px 12px rgba(243,156,18,0.3); }

  /* ---- Guess Area ---- */
  .guess-area {
    background: var(--bg-card);
    border-radius: 16px;
    padding: 18px;
    margin: 14px 0;
    border: 1px solid #222244;
    display: none;
  }
  .guess-area.active { display: block; animation: slideUp 0.3s ease; }

  @keyframes slideUp {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .guess-area h3 {
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-dim);
    margin-bottom: 10px;
  }

  .guess-input-row { display: flex; gap: 10px; }

  .guess-input {
    flex: 1;
    padding: 12px 16px;
    background: rgba(255,255,255,0.05);
    border: 2px solid #333;
    border-radius: 12px;
    color: var(--text);
    font-family: 'Nunito', sans-serif;
    font-size: 1rem;
    font-weight: 600;
    outline: none;
    transition: border-color 0.2s;
  }
  .guess-input:focus { border-color: var(--accent); }
  .guess-input::placeholder { color: var(--text-dim); }

  .guess-feedback {
    margin-top: 8px;
    font-size: 0.85rem;
    min-height: 1.2em;
  }

  /* ---- Song Library ---- */
  .library {
    background: var(--bg-card);
    border-radius: 16px;
    padding: 20px;
    margin: 20px 0;
    border: 1px solid #222244;
  }

  .library-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 14px;
  }

  .library-header h3 {
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-dim);
  }

  .library-actions {
    display: flex;
    gap: 8px;
  }

  .btn-sm {
    padding: 6px 14px;
    border: none;
    border-radius: 8px;
    font-family: 'Nunito', sans-serif;
    font-weight: 700;
    font-size: 0.78rem;
    cursor: pointer;
    transition: all 0.2s;
  }
  .btn-sm:hover { transform: translateY(-1px); }

  .btn-sm.random { background: linear-gradient(135deg, var(--pink), #a020f0); color: white; }
  .btn-sm.refresh { background: rgba(255,255,255,0.08); color: var(--text-dim); border: 1px solid #333; }

  .song-count {
    font-size: 0.8rem;
    color: var(--text-dim);
    margin-bottom: 12px;
  }

  /* Search */
  .search-box {
    width: 100%;
    padding: 10px 16px;
    background: rgba(255,255,255,0.04);
    border: 1px solid #2a2a4a;
    border-radius: 10px;
    color: var(--text);
    font-family: 'Nunito', sans-serif;
    font-size: 0.9rem;
    outline: none;
    margin-bottom: 12px;
    transition: border-color 0.2s;
  }
  .search-box:focus { border-color: var(--accent); }
  .search-box::placeholder { color: #555; }

  /* Song list */
  .song-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
    max-height: 400px;
    overflow-y: auto;
    padding-right: 4px;
  }

  .song-list::-webkit-scrollbar { width: 6px; }
  .song-list::-webkit-scrollbar-track { background: transparent; }
  .song-list::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }

  .song-item {
    padding: 12px 16px;
    background: rgba(255,255,255,0.02);
    border: 1px solid #2a2a4a;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .song-item:hover { background: rgba(247,183,49,0.06); border-color: var(--accent); }
  .song-item.active { background: rgba(247,183,49,0.1); border-color: var(--accent); box-shadow: 0 0 16px var(--accent-glow); }

  .song-info .title { font-weight: 700; font-size: 0.95rem; }
  .song-info .artist { color: var(--text-dim); font-size: 0.82rem; margin-top: 1px; }
  .song-info .meta { color: #555; font-size: 0.72rem; margin-top: 3px; }

  .song-right { display: flex; align-items: center; gap: 10px; }

  .difficulty {
    font-size: 0.68rem;
    padding: 3px 10px;
    border-radius: 8px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  .difficulty.easy { background: rgba(0,184,148,0.15); color: var(--success); }
  .difficulty.medium { background: rgba(247,183,49,0.15); color: var(--accent); }
  .difficulty.hard { background: rgba(214,48,49,0.15); color: var(--danger); }

  .no-video-badge {
    font-size: 0.65rem;
    padding: 2px 8px;
    border-radius: 6px;
    background: rgba(136,136,170,0.15);
    color: var(--text-dim);
  }

  /* ---- Empty state ---- */
  .empty-state {
    text-align: center;
    padding: 40px 20px;
    color: var(--text-dim);
  }
  .empty-state .icon { font-size: 3rem; margin-bottom: 12px; opacity: 0.5; }
  .empty-state h3 { color: var(--text); margin-bottom: 8px; }
  .empty-state p { font-size: 0.88rem; line-height: 1.6; max-width: 500px; margin: 0 auto; }
  .empty-state code {
    display: block;
    background: rgba(255,255,255,0.05);
    padding: 14px;
    border-radius: 10px;
    margin: 14px auto;
    text-align: left;
    max-width: 420px;
    font-size: 0.82rem;
    line-height: 1.7;
    color: var(--accent);
  }

  /* ---- Info Panel ---- */
  .info-panel {
    background: var(--bg-card);
    border-radius: 16px;
    padding: 20px;
    margin: 20px 0;
    border: 1px solid #222244;
  }
  .info-panel h3 {
    font-family: 'Dela Gothic One', cursive;
    font-size: 0.95rem;
    color: var(--accent);
    margin-bottom: 10px;
  }
  .info-panel p {
    color: var(--text-dim);
    font-size: 0.88rem;
    line-height: 1.6;
    margin-bottom: 6px;
  }
  .info-panel kbd {
    background: rgba(255,255,255,0.08);
    padding: 2px 7px;
    border-radius: 5px;
    font-size: 0.78rem;
    border: 1px solid #444;
    font-family: 'Nunito', sans-serif;
  }

  /* ---- Loading overlay ---- */
  .loading-overlay {
    position: fixed; inset: 0;
    background: rgba(10,10,26,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    flex-direction: column;
    gap: 16px;
    transition: opacity 0.3s;
  }
  .loading-overlay.hidden { opacity: 0; pointer-events: none; }
  .spinner {
    width: 40px; height: 40px;
    border: 4px solid #333;
    border-top: 4px solid var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* ---- Room Selection Screen ---- */
  .room-screen {
    position: fixed;
    inset: 0;
    background: var(--bg-dark);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .room-screen.hidden { display: none; }

  .room-box {
    background: var(--bg-card);
    border: 1px solid #222244;
    border-radius: 20px;
    padding: 40px;
    max-width: 460px;
    width: 90%;
    text-align: center;
  }

  .room-box h1 {
    font-family: 'Dela Gothic One', cursive;
    font-size: 1.6rem;
    background: linear-gradient(135deg, var(--accent), var(--pink));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 8px;
  }

  .room-box .subtitle { color: var(--text-dim); font-size: 0.9rem; margin-bottom: 28px; }

  .room-input-group {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
  }

  .room-input {
    flex: 1;
    padding: 12px 16px;
    border-radius: 12px;
    border: 2px solid #333;
    background: #1a1a2e;
    color: var(--text);
    font-size: 1rem;
    font-weight: 700;
    text-align: center;
    letter-spacing: 1px;
    outline: none;
    transition: border-color 0.3s;
  }
  .room-input:focus { border-color: var(--accent); }
  .room-input::placeholder { color: var(--text-dim); font-weight: 400; letter-spacing: 0; }

  .room-btn {
    padding: 12px 24px;
    border-radius: 12px;
    border: none;
    font-weight: 700;
    font-size: 0.95rem;
    cursor: pointer;
    transition: all 0.2s;
  }
  .room-btn.primary {
    background: linear-gradient(135deg, var(--accent), #e6a020);
    color: #000;
  }
  .room-btn.primary:hover { transform: scale(1.05); }
  .room-btn.secondary {
    background: #2a2a4a;
    color: var(--text);
    width: 100%;
    margin-top: 8px;
  }
  .room-btn.secondary:hover { background: #3a3a5a; }

  .room-or {
    color: var(--text-dim);
    font-size: 0.8rem;
    margin: 16px 0;
    text-transform: uppercase;
    letter-spacing: 2px;
  }

  .room-error {
    color: var(--danger);
    font-size: 0.8rem;
    margin-top: 8px;
    min-height: 20px;
  }

  .room-badge {
    display: inline-block;
    background: #2a2a4a;
    border: 1px solid #333;
    border-radius: 10px;
    padding: 6px 14px;
    font-size: 0.8rem;
    color: var(--accent);
    font-weight: 700;
    letter-spacing: 1px;
    margin: 8px 0;
    cursor: pointer;
  }
  .room-badge:hover { background: #3a3a5a; }

  /* ---- Responsive ---- */
  @media (max-width: 600px) {
    .header h1 { font-size: 1.3rem; }
    .subtitle-text { font-size: 1.1rem; }
    .controls { gap: 6px; }
    .btn { padding: 9px 16px; font-size: 0.82rem; }
  }

  /* ---- Volume Control ---- */
  .volume-control {
    display: flex;
    align-items: center;
    gap: 10px;
    background: var(--bg-card);
    border-radius: 12px;
    padding: 10px 16px;
    border: 1px solid #222244;
    margin: 10px 0;
  }

  .volume-control .vol-icon {
    font-size: 1.1rem;
    cursor: pointer;
    user-select: none;
    min-width: 28px;
    text-align: center;
  }

  .volume-slider {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    border-radius: 3px;
    background: #2a2a4a;
    outline: none;
    cursor: pointer;
  }

  .volume-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 8px var(--accent-glow);
    transition: transform 0.15s;
  }

  .volume-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
  }

  .volume-slider::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: none;
    box-shadow: 0 0 8px var(--accent-glow);
  }

  .volume-pct {
    font-size: 0.78rem;
    color: var(--text-dim);
    min-width: 36px;
    text-align: right;
    font-variant-numeric: tabular-nums;
  }

  /* ---- Cutoff window markers on progress bar ---- */
  .cutoff-window-marker {
    position: absolute;
    top: -2px;
    height: 10px;
    background: rgba(214, 48, 49, 0.35);
    border-left: 2px solid var(--danger);
    border-right: 2px solid var(--danger);
    border-radius: 3px;
    z-index: 2;
    box-shadow: 0 0 6px rgba(214, 48, 49, 0.3);
    pointer-events: none;
  }

  /* ---- Window progress indicator ---- */
  .window-progress {
    background: var(--bg-card);
    border-radius: 12px;
    padding: 12px 16px;
    margin: 10px 0;
    border: 1px solid #222244;
    display: none;
  }

  .window-progress.active { display: block; animation: slideUp 0.3s ease; }

  .window-progress-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }

  .window-progress-header .wp-label {
    font-size: 0.8rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-dim);
  }

  .window-progress-header .wp-count {
    font-size: 0.85rem;
    font-weight: 800;
    color: var(--accent);
  }

  .wp-bar-container {
    height: 8px;
    background: #2a2a4a;
    border-radius: 4px;
    overflow: hidden;
  }

  .wp-bar-fill {
    height: 100%;
    border-radius: 4px;
    transition: width 0.4s ease, background 0.3s;
    background: linear-gradient(90deg, var(--accent), var(--pink));
  }

  .wp-bar-fill.complete {
    background: linear-gradient(90deg, var(--success), var(--blue));
  }

  .window-complete-msg {
    margin-top: 8px;
    text-align: center;
    font-weight: 700;
    font-size: 0.9rem;
    color: var(--success);
    display: none;
    animation: revealPop 0.5s ease;
  }

  .window-complete-msg.show { display: block; }
</style>
</head>
<body>

<!-- Room Selection -->
<div class="room-screen" id="roomScreen">
  <div class="room-box">
    <h1>üé§ N'oubliez pas les Paroles</h1>
    <p class="subtitle">Cr√©ez ou rejoignez une room pour commencer</p>

    <div class="room-input-group">
      <input type="text" class="room-input" id="roomInput"
             placeholder="Nom de room (ex: wilfried)"
             maxlength="20"
             onkeydown="if(event.key==='Enter') joinRoom()"
             oninput="this.value = this.value.toLowerCase().replace(/[^a-z0-9-]/g, '')">
      <button class="room-btn primary" onclick="joinRoom()">Rejoindre</button>
    </div>
    <div class="room-error" id="roomError"></div>

    <div class="room-or">‚Äî ou ‚Äî</div>

    <button class="room-btn secondary" onclick="createRandomRoom()">üé≤ Cr√©er une room al√©atoire</button>
  </div>
</div>

<!-- Loading -->
<div class="loading-overlay" id="loadingOverlay">
  <div class="spinner"></div>
  <div style="color: var(--text-dim); font-size: 0.9rem;">Chargement de la biblioth√®que...</div>
</div>

<div class="app">
  <div class="header">
    <h1>üé§ N'oubliez pas les Paroles</h1>
    <p>Karaok√© interactif avec coupure de son</p>
    <div class="room-badge" id="roomBadge" onclick="copyOverlayUrl()" title="Cliquer pour copier l'URL overlay">
      Room : <span id="roomDisplay">‚Äî</span>
    </div>
    <span id="copyMsg" style="color:var(--success);font-size:0.75rem;opacity:0;transition:opacity 0.3s;">‚úì URL overlay copi√©e !</span>
  </div>

  <!-- Video Stage -->
  <div class="video-stage" id="videoStage">
    <video id="videoPlayer" playsinline crossorigin="anonymous"></video>

    <div class="placeholder" id="placeholder">
      <div class="icon">üé¨</div>
      <div class="msg">S√©lectionnez une chanson pour commencer</div>
    </div>

    <div class="score-display" style="display:none" id="scoreBox">
      <div class="label">Score</div>
      <div class="value" id="scoreValue">0</div>
    </div>

    <div class="status-bar">
      <div class="status-pill paused" id="statusPill">‚è∏ En attente</div>
    </div>

    <div class="subtitle-overlay">
      <div class="subtitle-text" id="subtitleText"></div>
    </div>
  </div>

  <!-- Progress -->
  <div class="progress-container" id="progressContainer">
    <div id="cutoffMarkers"></div>
    <div class="progress-bar" id="progressBar"></div>
  </div>
  <div class="time-display">
    <span><span id="currentTime">0:00</span> / <span id="totalTime">0:00</span></span>
    <span id="cutoffInfo" style="color: var(--danger);"></span>
  </div>

  <!-- Volume -->
  <div class="volume-control">
    <span class="vol-icon" id="volIcon" onclick="toggleMuteManual()">üîä</span>
    <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="80" oninput="setVolume(this.value)">
    <span class="volume-pct" id="volumePct">80%</span>
  </div>

  <!-- Controls -->
  <div class="controls">
    <button class="btn btn-primary" id="btnPlay" onclick="togglePlay()" disabled>‚ñ∂ Jouer</button>
    <button class="btn btn-success" id="btnReveal" onclick="revealNext()" disabled>üëÅ R√©v√©ler</button>
    <button class="btn btn-secondary" onclick="resetGame()">‚Ü∫ Reset</button>
  </div>

  <!-- Sound mode option -->
  <div class="sound-mode-option" id="soundModeOption">
    <label class="sound-mode-label">
      <input type="checkbox" id="soundModeCheck" onchange="toggleSoundMode()">
      <span class="checkmark"></span>
      üîä Rejouer le son apr√®s avoir trouv√© tous les mots
    </label>
  </div>

  <!-- Guess Area -->
  <div class="guess-area" id="guessArea">
    <h3>üé§ Devinez les paroles</h3>
    <div class="guess-input-row">
      <input type="text" class="guess-input" id="guessInput"
             placeholder="Tapez un ou plusieurs mots..."
             onkeydown="if(event.key==='Enter') checkGuess()" autocomplete="off">
      <button class="btn btn-primary" onclick="checkGuess()">OK</button>
    </div>
    <div class="guess-feedback" id="guessFeedback"></div>
    <div style="margin-top:8px;font-size:0.78rem;color:var(--text-dim)">
      üí° Vous pouvez taper plusieurs mots ou une phrase enti√®re. Appuyez sur ‚ñ∂ pour continuer la musique.
    </div>
  </div>

  <!-- Window Progress -->
  <div class="window-progress" id="windowProgress">
    <div class="window-progress-header">
      <span class="wp-label" id="wpLabel">Fen√™tre 1/1</span>
      <span class="wp-count" id="wpCount">0 / 0 mots</span>
    </div>
    <div class="wp-bar-container">
      <div class="wp-bar-fill" id="wpBarFill" style="width:0%"></div>
    </div>
    <div class="window-complete-msg" id="wpComplete">
      ‚úÖ Fen√™tre compl√®te ! Appuyez sur ‚ñ∂ Reprendre pour continuer
    </div>
  </div>

  <!-- Library -->
  <div class="library">
    <div class="library-header">
      <h3>üìö Biblioth√®que</h3>
      <div class="library-actions">
        <button class="btn-sm random" onclick="pickRandom()">üé≤ Au hasard</button>
        <button class="btn-sm refresh" onclick="refreshLibrary()">‚Üª Rafra√Æchir</button>
      </div>
    </div>
    <div class="song-count" id="songCount"></div>
    <input type="text" class="search-box" id="searchBox" placeholder="üîç Rechercher une chanson ou un artiste..." oninput="filterSongs()">
    <div class="song-list" id="songList"></div>
  </div>

  <!-- Info -->
  <div class="info-panel">
    <h3>üì° Mode Stream (OBS)</h3>
    <p>
      Cette page est la <strong>r√©gie</strong> ‚Äî vous contr√¥lez tout depuis ici.
      Pour afficher dans OBS, ajoutez une <strong>Source Navigateur</strong> avec l'URL overlay
      (cliquez sur le badge room ci-dessus pour copier).
    </p>
    <p>
      <kbd id="overlayUrl" style="cursor:pointer;display:inline-block;padding:6px 12px;font-size:0.85rem;" onclick="copyOverlayUrl()" title="Cliquer pour copier">
        chargement...
      </kbd>
    </p>
    <p>
      L'overlay est transparent, sans contr√¥les ‚Äî juste la vid√©o, les sous-titres et le score.
      Taille recommand√©e : <kbd>1280√ó720</kbd>.
      Votre URL overlay est <strong>permanente</strong> tant que vous gardez le m√™me nom de room.
    </p>
  </div>

  <div class="info-panel">
    <h3>Guide rapide</h3>
    <p>
      Placez vos chansons dans le dossier <kbd>videos/</kbd> √† c√¥t√© de <kbd>server.py</kbd>.
      Chaque chanson doit avoir son propre sous-dossier avec au minimum un fichier <kbd>.srt</kbd>
      (sous-titres). Ajoutez un <kbd>config.json</kbd> pour personnaliser le titre, artiste, difficult√© et point de coupure.
    </p>
    <p>
      Pour g√©n√©rer les sous-titres automatiquement avec Whisper :<br>
      <kbd>whisper video.mp4 --language fr --output_format srt</kbd>
    </p>
    <p>
      <strong>Calage des paroles :</strong> si les sous-titres sont d√©cal√©s par rapport √† la voix,
      ajoutez <kbd>"subtitle_offset"</kbd> dans config.json. Valeur en secondes :
      <kbd>-0.3</kbd> = avance de 300ms, <kbd>0.5</kbd> = retarde de 500ms.
    </p>
    <p>
      Les fen√™tres de coupure acceptent les d√©cimales : <kbd>[65.5, 95.2]</kbd>.
    </p>
  </div>
</div>

<script>
// ============================================================
// STATE
// ============================================================
const API = '';
let currentRoom = null;     // room ID
let songs = [];
let currentSong = null;
let isMuted = false;       // game mute (cutoff active)
let score = 0;
let revealedWords = new Set();
let hiddenWordIndices = [];
let subtitleInterval = null;
let currentWindowIdx = -1; // which cutoff window we're in (-1 = none)
let savedVolume = 0.8;     // remember volume before game mute
let lastSubtitleHtml = '';  // track last rendered HTML to avoid flickering
let lastLineIdx = -1;       // track current line to detect changes
let replayAfterComplete = false; // sound mode: replay sound after all words found

const video = document.getElementById('videoPlayer');
video.volume = 0.8;

// End of video ‚Üí show final score
video.addEventListener('ended', () => {
  pause();
  showFinalScore();
});

// Update total time when video metadata loads
video.addEventListener('loadedmetadata', () => {
  if (video.duration && !isNaN(video.duration)) {
    document.getElementById('totalTime').textContent = formatTime(video.duration);
  }
});

// ============================================================
// API CALLS
// ============================================================
async function fetchSongs() {
  try {
    const res = await fetch(`${API}/api/songs`);
    const data = await res.json();
    return data.songs || [];
  } catch (e) {
    console.error('Erreur de connexion au serveur:', e);
    return [];
  }
}

async function fetchSongDetail(id) {
  const res = await fetch(`${API}/api/songs/${id}`);
  return res.json();
}

async function fetchRandomSong() {
  const res = await fetch(`${API}/api/random`);
  return res.json();
}

async function refreshLibrary() {
  showLoading(true);
  try {
    const res = await fetch(`${API}/api/refresh`);
    const data = await res.json();
    songs = data.songs || [];
    renderSongList(songs);
  } catch (e) {
    console.error('Erreur refresh:', e);
  }
  showLoading(false);
}

// ============================================================
// UI RENDERING
// ============================================================
function renderSongList(list) {
  const container = document.getElementById('songList');
  document.getElementById('songCount').textContent = `${list.length} chanson${list.length > 1 ? 's' : ''} disponible${list.length > 1 ? 's' : ''}`;

  if (list.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <div class="icon">üìÅ</div>
        <h3>Aucune chanson trouv√©e</h3>
        <p>Ajoutez des chansons dans le dossier <strong>videos/</strong> avec cette structure :</p>
        <code>
          videos/<br>
          &nbsp;&nbsp;ma-chanson/<br>
          &nbsp;&nbsp;&nbsp;&nbsp;video.mp4<br>
          &nbsp;&nbsp;&nbsp;&nbsp;subtitles.srt<br>
          &nbsp;&nbsp;&nbsp;&nbsp;config.json <span style="color:var(--text-dim)">(optionnel)</span>
        </code>
        <p>Puis cliquez sur <strong>‚Üª Rafra√Æchir</strong></p>
      </div>`;
    return;
  }

  container.innerHTML = list.map(song => {
    const diffLabel = {easy:'Facile', medium:'Moyen', hard:'Difficile'}[song.difficulty] || 'Moyen';
    const isActive = currentSong && currentSong.id === song.id;
    const duration = formatTime(song.duration);
    const windows = song.cutoff_windows || [];
    const windowsStr = windows.map(w => `${formatTime(w[0])}‚Üí${formatTime(w[1])}`).join(', ');

    return `
      <div class="song-item ${isActive ? 'active' : ''}" onclick="selectSong('${song.id}')">
        <div class="song-info">
          <div class="title">${song.title}</div>
          <div class="artist">${song.artist}</div>
          <div class="meta">${duration} ‚Ä¢ ‚úÇ ${windowsStr}</div>
        </div>
        <div class="song-right">
          ${!song.has_video ? '<span class="no-video-badge">SRT seul</span>' : ''}
          <span class="difficulty ${song.difficulty}">${diffLabel}</span>
        </div>
      </div>`;
  }).join('');
}

function filterSongs() {
  const q = document.getElementById('searchBox').value.toLowerCase().trim();
  if (!q) {
    renderSongList(songs);
    return;
  }
  const filtered = songs.filter(s =>
    s.title.toLowerCase().includes(q) ||
    s.artist.toLowerCase().includes(q)
  );
  renderSongList(filtered);
}

function showLoading(show) {
  document.getElementById('loadingOverlay').classList.toggle('hidden', !show);
}

// ============================================================
// SONG SELECTION
// ============================================================
async function selectSong(id) {
  resetGame();
  showLoading(true);

  try {
    currentSong = await fetchSongDetail(id);
  } catch (e) {
    console.error('Erreur chargement chanson:', e);
    showLoading(false);
    return;
  }

  // Setup video
  const placeholder = document.getElementById('placeholder');
  if (currentSong.video_url) {
    video.src = currentSong.video_url;
    video.load();
    placeholder.style.display = 'none';
  } else {
    video.removeAttribute('src');
    placeholder.style.display = 'flex';
    placeholder.querySelector('.msg').textContent = `üéµ ${currentSong.title} ‚Äî ${currentSong.artist} (audio seul)`;
  }

  // Update UI
  document.getElementById('totalTime').textContent = formatTime(currentSong.duration);
  renderCutoffMarkers();

  document.getElementById('btnPlay').disabled = false;
  document.getElementById('scoreBox').style.display = 'block';

  document.getElementById('subtitleText').innerHTML =
    `<span class="word" style="color: var(--accent);">‚ô™ ${currentSong.title} ‚Äî ${currentSong.artist} ‚ô™</span>`;

  // Update active state in list
  renderSongList(songs.length ? songs : [currentSong]);

  showLoading(false);
}

async function pickRandom() {
  if (songs.length === 0) return;
  resetGame();
  showLoading(true);

  try {
    const song = await fetchRandomSong();
    // We have the full detail already from /api/random
    currentSong = song;

    const placeholder = document.getElementById('placeholder');
    if (currentSong.video_url) {
      video.src = currentSong.video_url;
      video.load();
      placeholder.style.display = 'none';
    } else {
      video.removeAttribute('src');
      placeholder.style.display = 'flex';
      placeholder.querySelector('.msg').textContent = `üéµ ${currentSong.title} ‚Äî ${currentSong.artist}`;
    }

    document.getElementById('totalTime').textContent = formatTime(currentSong.duration);
    renderCutoffMarkers();

    document.getElementById('btnPlay').disabled = false;
    document.getElementById('scoreBox').style.display = 'block';
    document.getElementById('subtitleText').innerHTML =
      `<span class="word" style="color: var(--accent);">üé≤ ${currentSong.title} ‚Äî ${currentSong.artist} ‚ô™</span>`;

    renderSongList(songs);
  } catch (e) {
    console.error('Erreur random:', e);
  }
  showLoading(false);
}

// ============================================================
// PLAYBACK
// ============================================================
function togglePlay() {
  if (!currentSong) return;
  if (video.paused || !video.src) {
    play();
  } else {
    pause();
  }
}

function play() {
  if (currentSong.video_url && video.src) {
    video.play().catch(() => {});
  }
  document.getElementById('btnPlay').innerHTML = '‚è∏ Pause';
  updateStatus(isMuted ? 'muted' : 'playing');
  startSubtitleLoop();
  updateRevealButton();
}

function pause() {
  if (video.src) video.pause();
  document.getElementById('btnPlay').innerHTML = '‚ñ∂ Reprendre';
  updateStatus(isMuted ? 'muted' : 'paused');
  stopSubtitleLoop();
  updateRevealButton();
}

function startSubtitleLoop() {
  stopSubtitleLoop();
  subtitleInterval = setInterval(updateSubtitles, 80);
}

function stopSubtitleLoop() {
  if (subtitleInterval) clearInterval(subtitleInterval);
  subtitleInterval = null;
}

function getCurrentTime() {
  if (video.src && !isNaN(video.currentTime)) return video.currentTime;
  return 0;
}

function updateSubtitles() {
  if (!currentSong || !currentSong.lyrics) return;
  const t = getCurrentTime();

  // Use actual video duration if available, fallback to SRT duration
  const duration = (video.duration && !isNaN(video.duration)) ? video.duration : (currentSong.duration || 1);
  const pct = Math.min((t / duration) * 100, 100);
  document.getElementById('progressBar').style.width = `${pct}%`;
  document.getElementById('currentTime').textContent = formatTime(t);

  // Auto cutoff/unmute based on windows
  const windows = currentSong.cutoff_windows || [];
  const inWindow = windows.findIndex(w => t >= w[0] && t < w[1]);

  if (inWindow !== -1 && !isMuted) {
    // Entering a cutoff window ‚Üí mute + auto pause
    currentWindowIdx = inWindow;
    triggerCutoff();
    return; // pause stops the loop
  } else if (inWindow === -1 && isMuted) {
    // Exiting a cutoff window ‚Üí restore sound
    restoreSound();
  }

  // Find current lyric line
  renderCurrentSubtitle(t);
}

function renderCurrentSubtitle(t, force) {
  // Apply subtitle offset from config
  const offset = (currentSong && currentSong.subtitle_offset) ? currentSong.subtitle_offset : 0;
  const adjustedT = t + offset;

  const lyrics = currentSong._processedLyrics || currentSong.lyrics;
  const currentLine = lyrics.find(l => adjustedT >= l.start && adjustedT < l.end);
  const subtitleEl = document.getElementById('subtitleText');

  if (currentLine) {
    const lineIdx = lyrics.indexOf(currentLine);
    const tokens = currentLine.tokens || currentLine.text.split(/\s+/).map((t, i) => ({ text: t, origWordIdx: i, isHyphen: false }));
    const wordProgress = (adjustedT - currentLine.start) / (currentLine.end - currentLine.start);
    const highlightIdx = Math.floor(wordProgress * tokens.length);

    // Determine which window this line belongs to (for display scoping)
    const windows = currentSong.cutoff_windows || [];
    const lineWinIdx = windows.findIndex(w => currentLine.end > w[0] && currentLine.start < w[1]);

    // Build new HTML
    let inParens = false;
    const html = tokens.map((token, ti) => {
      if (token.text.includes('(')) inParens = true;
      const isParenWord = inParens;
      if (token.text.includes(')')) inParens = false;

      const key = `${lineIdx}-${ti}`;
      const isRevealed = revealedWords.has(key);
      const isInHiddenList = hiddenWordIndices.some(h => h.lineIdx === lineIdx && h.tokenIdx === ti);
      const isPunctOnly = normalizeWord(token.text).length === 0;

      // Only hide if this word belongs to the current or a future window
      // Words already found in previous windows stay revealed
      const isHidden = isInHiddenList && !isRevealed && !isPunctOnly && !isParenWord;

      if (token.isHyphen) {
        // Always show hyphens
        return `<span class="word" style="margin:0 -2px;">-</span>`;
      } else if (isHidden) {
        const match = token.text.match(/^([^a-zA-Z√Ä-√ø0-9]*)(.*?)([^a-zA-Z√Ä-√ø0-9]*)$/);
        const prefix = match ? match[1] : '';
        const core = match ? match[2] : token.text;
        const suffix = match ? match[3] : '';
        return `${escapeHtml(prefix)}<span class="word hidden-word">${escapeHtml(core)}</span>${escapeHtml(suffix)}`;
      } else if (isRevealed) {
        return `<span class="word revealed-static">${escapeHtml(token.text)}</span>`;
      } else if (isParenWord) {
        return `<span class="word backing-vocal">${escapeHtml(token.text)}</span>`;
      } else {
        const cls = (!isMuted && ti === highlightIdx) ? 'highlighted' : '';
        return `<span class="word ${cls}">${escapeHtml(token.text)}</span>`;
      }
    }).join(' ');

    if (html !== lastSubtitleHtml || force) {
      subtitleEl.innerHTML = html;
      lastSubtitleHtml = html;
    }
    lastLineIdx = lineIdx;
  } else {
    let placeholder;
    if (!isMuted) {
      placeholder = '<span class="word" style="color:var(--text-dim)">‚ô™ ‚ô™ ‚ô™</span>';
    } else {
      placeholder = '<span class="word" style="color:var(--danger)">üîá √Ä vous de chanter !</span>';
    }
    if (placeholder !== lastSubtitleHtml) {
      subtitleEl.innerHTML = placeholder;
      lastSubtitleHtml = placeholder;
    }
    lastLineIdx = -1;
  }
}

// ============================================================
// GAME MECHANICS
// ============================================================
function triggerCutoff() {
  if (isMuted) return;
  isMuted = true;

  // Mute video
  savedVolume = video.volume;
  video.volume = 0;

  // Build hidden words for ALL windows (not just current)
  buildAllHiddenWords();

  // Auto-pause so the player has time to answer
  pause();

  updateStatus('muted');
  updateRevealButton();
  document.getElementById('guessArea').classList.add('active');
  document.getElementById('guessInput').focus();

  // Show window progress
  document.getElementById('windowProgress').classList.add('active');
  updateWindowProgress();

  // Show the hidden lyrics for the current position
  renderCurrentSubtitle(getCurrentTime());
}

function restoreSound() {
  if (!isMuted) return;
  isMuted = false;
  currentWindowIdx = -1;

  // Restore volume
  video.volume = savedVolume;

  updateRevealButton();
  updateStatus('playing');
}

function toggleSoundMode() {
  replayAfterComplete = document.getElementById('soundModeCheck').checked;
}

function updateRevealButton() {
  const btn = document.getElementById('btnReveal');
  // Only active when muted (in a cutoff window) AND video is paused AND window not complete
  if (!isMuted || !video.paused) {
    btn.disabled = true;
    return;
  }

  const winIdx = currentWindowIdx >= 0 ? currentWindowIdx : 0;
  const windowWords = hiddenWordIndices.filter(h => h.windowIdx === winIdx);
  const allFound = windowWords.length > 0 && windowWords.every(h => {
    const key = `${h.lineIdx}-${h.tokenIdx}`;
    return revealedWords.has(key);
  });

  btn.disabled = allFound;
}

// Called when all words in current window are found
function onWindowComplete() {
  updateRevealButton();

  if (replayAfterComplete) {
    // Restore sound and auto-play so the player can hear the passage
    video.volume = savedVolume;
    // Keep isMuted true so we re-mute when leaving the window
    play();
  }
}

function buildAllHiddenWords() {
  // Only rebuild if not already built (avoid wiping progress on re-entry)
  if (hiddenWordIndices.length > 0) return;

  hiddenWordIndices = [];
  const windows = currentSong.cutoff_windows || [];

  // Pre-process lyrics: split hyphenated words into sub-tokens
  // We store a mapping so we know which sub-tokens belong to which original word
  if (!currentSong._processedLyrics) {
    currentSong._processedLyrics = currentSong.lyrics.map(line => {
      const origWords = line.text.split(/\s+/);
      const tokens = []; // { text, origWordIdx, isHyphen }
      origWords.forEach((word, wi) => {
        // Split on hyphens: "peut-√™tre" ‚Üí ["peut", "-", "√™tre"]
        const parts = word.split(/(-)/);
        parts.forEach(part => {
          if (part.length > 0) {
            tokens.push({ text: part, origWordIdx: wi, isHyphen: part === '-' });
          }
        });
      });
      return { ...line, tokens };
    });
  }

  currentSong._processedLyrics.forEach((line, lineIdx) => {
    const winIdx = windows.findIndex(w => line.end > w[0] && line.start < w[1]);
    if (winIdx !== -1) {
      let inParentheses = false;

      line.tokens.forEach((token, tokenIdx) => {
        if (token.text.includes('(')) inParentheses = true;

        const cleaned = normalizeWord(token.text);
        if (cleaned.length > 0 && !inParentheses && !token.isHyphen) {
          hiddenWordIndices.push({
            lineIdx, tokenIdx, word: token.text, windowIdx: winIdx
          });
        }

        if (token.text.includes(')')) inParentheses = false;
      });
    }
  });

  console.log(`[buildAllHiddenWords] ${hiddenWordIndices.length} mots cach√©s sur ${windows.length} fen√™tre(s)`,
    windows.map((w, i) => `F${i+1}: ${hiddenWordIndices.filter(h => h.windowIdx === i).length} mots`).join(', ')
  );
}

function isTimeInCutoffWindow(t) {
  const windows = currentSong.cutoff_windows || [];
  return windows.some(w => t >= w[0] && t < w[1]);
}

// ============================================================
// MULTI-WORD FLEXIBLE MATCHING
// ============================================================
function checkGuess() {
  const input = document.getElementById('guessInput');
  const feedback = document.getElementById('guessFeedback');
  const rawGuess = input.value.trim();
  if (!rawGuess) return;

  // Split input into individual words
  const guessWords = rawGuess.split(/\s+/).map(w => normalizeWord(w)).filter(w => w.length > 0);
  if (guessWords.length === 0) return;

  const winIdx = currentWindowIdx >= 0 ? currentWindowIdx : 0;
  let totalFound = 0;
  let foundDisplayWords = [];

  // For each guess word, only match hidden words in the CURRENT window
  for (const guessWord of guessWords) {
    for (const item of hiddenWordIndices) {
      // Only match in current window
      if (item.windowIdx !== winIdx) continue;

      const key = `${item.lineIdx}-${item.tokenIdx}`;
      if (revealedWords.has(key)) continue;

      const hiddenClean = normalizeWord(item.word);
      if (hiddenClean.length === 0) continue;

      if (wordsMatch(guessWord, hiddenClean)) {
        // Reveal ALL instances of this word in the CURRENT window only
        const matchNorm = hiddenClean;
        for (const other of hiddenWordIndices) {
          if (other.windowIdx !== winIdx) continue;
          const otherKey = `${other.lineIdx}-${other.tokenIdx}`;
          if (revealedWords.has(otherKey)) continue;
          if (normalizeWord(other.word) === matchNorm) {
            revealedWords.add(otherKey);
            score += 10;
            totalFound++;
          }
        }
        foundDisplayWords.push(item.word);
        break; // Move to next guess word
      }
    }
  }

  if (totalFound > 0) {
    document.getElementById('scoreValue').textContent = score;
    input.value = '';
    input.style.borderColor = 'var(--success)';

    const wordsStr = foundDisplayWords.map(w => `"${w}"`).join(', ');
    const countInfo = totalFound > foundDisplayWords.length
      ? ` (+${totalFound - foundDisplayWords.length} identiques)`
      : '';
    feedback.innerHTML = `<span style="color:var(--success)">‚úì ${wordsStr} trouv√© !${countInfo}</span>`;

    setTimeout(() => { input.style.borderColor = '#333'; }, 600);

    // Refresh subtitle display (force to show animation)
    lastSubtitleHtml = ''; // force DOM update
    renderCurrentSubtitle(getCurrentTime(), true);
    checkWin();
  } else {
    input.style.borderColor = 'var(--danger)';
    feedback.innerHTML = `<span style="color:var(--danger)">‚úó Pas trouv√©... R√©essayez !</span>`;
    setTimeout(() => { input.style.borderColor = '#333'; }, 600);
  }
}

function normalizeWord(str) {
  // Remove punctuation, accents, lowercase
  return str
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')  // remove accents
    .replace(/[^a-z0-9]/g, '');       // remove punctuation
}

function wordsMatch(guess, target) {
  // Exact match
  if (guess === target) return true;

  // Flexible: allow 1 character difference for words > 3 chars (typo tolerance)
  if (guess.length > 3 && target.length > 3) {
    const dist = levenshtein(guess, target);
    if (dist <= 1) return true;
  }

  // Allow missing trailing 's' or 'e' (common French flex)
  if (guess + 's' === target || guess + 'e' === target) return true;
  if (target + 's' === guess || target + 'e' === guess) return true;

  return false;
}

function levenshtein(a, b) {
  const m = a.length, n = b.length;
  const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      dp[i][j] = Math.min(
        dp[i-1][j] + 1,
        dp[i][j-1] + 1,
        dp[i-1][j-1] + (a[i-1] !== b[j-1] ? 1 : 0)
      );
    }
  }
  return dp[m][n];
}

function revealNext() {
  const winIdx = currentWindowIdx >= 0 ? currentWindowIdx : 0;

  // Try current window first
  for (const item of hiddenWordIndices) {
    if (item.windowIdx !== winIdx) continue;
    const key = `${item.lineIdx}-${item.tokenIdx}`;
    if (!revealedWords.has(key)) {
      revealedWords.add(key);
      lastSubtitleHtml = '';
      renderCurrentSubtitle(getCurrentTime(), true);
      updateWindowProgress();
      return;
    }
  }
  // Then any other window
  for (const item of hiddenWordIndices) {
    const key = `${item.lineIdx}-${item.tokenIdx}`;
    if (!revealedWords.has(key)) {
      revealedWords.add(key);
      lastSubtitleHtml = '';
      renderCurrentSubtitle(getCurrentTime(), true);
      updateWindowProgress();
      return;
    }
  }
}

function checkWin() {
  updateWindowProgress();

  // Count unrevealed words in current window only
  const winIdx = currentWindowIdx >= 0 ? currentWindowIdx : 0;
  let remaining = 0;
  for (const item of hiddenWordIndices) {
    if (item.windowIdx !== winIdx) continue;
    const key = `${item.lineIdx}-${item.tokenIdx}`;
    if (!revealedWords.has(key)) remaining++;
  }

  if (remaining === 0) {
    // Current window is complete
    onWindowComplete();

    // Check if ALL windows are complete
    let totalRemaining = 0;
    for (const item of hiddenWordIndices) {
      const key = `${item.lineIdx}-${item.tokenIdx}`;
      if (!revealedWords.has(key)) totalRemaining++;
    }
    if (totalRemaining === 0) {
      document.getElementById('guessFeedback').innerHTML =
        `<span style="color:var(--accent)">üèÜ Toutes les paroles trouv√©es ! Bravo !</span>`;
      document.getElementById('wpComplete').textContent = 'üèÜ Tout trouv√© ! Bravo !';
    }
  }

  updateRevealButton();
}

function updateWindowProgress() {
  const windows = currentSong.cutoff_windows || [];
  const totalWindows = windows.length;
  const winIdx = currentWindowIdx >= 0 ? currentWindowIdx : 0;

  // Count words for current window
  const windowWords = hiddenWordIndices.filter(h => h.windowIdx === winIdx);
  const totalInWindow = windowWords.length;
  const foundInWindow = windowWords.filter(h => {
    const key = `${h.lineIdx}-${h.tokenIdx}`;
    return revealedWords.has(key);
  }).length;

  // Count total remaining across all windows
  let totalRemaining = 0;
  for (const item of hiddenWordIndices) {
    const key = `${item.lineIdx}-${item.tokenIdx}`;
    if (!revealedWords.has(key)) totalRemaining++;
  }

  // Update labels
  const label = document.getElementById('wpLabel');
  label.textContent = totalWindows > 1
    ? `Fen√™tre ${winIdx + 1}/${totalWindows}`
    : `Passage √† deviner`;

  const count = document.getElementById('wpCount');
  count.textContent = `${foundInWindow} / ${totalInWindow} mots`;

  // Update bar
  const pct = totalInWindow > 0 ? (foundInWindow / totalInWindow) * 100 : 0;
  const bar = document.getElementById('wpBarFill');
  bar.style.width = `${pct}%`;

  const completeMsg = document.getElementById('wpComplete');
  const windowComplete = (foundInWindow === totalInWindow && totalInWindow > 0);

  if (windowComplete) {
    bar.classList.add('complete');
    completeMsg.classList.add('show');

    if (totalRemaining > 0) {
      completeMsg.textContent = `‚úÖ Fen√™tre compl√®te ! Appuyez sur ‚ñ∂ Reprendre pour continuer (${totalRemaining} mots restants)`;
    } else {
      completeMsg.textContent = `üèÜ Tout trouv√© ! Bravo !`;
    }
  } else {
    bar.classList.remove('complete');
    completeMsg.classList.remove('show');
  }
}

function showFinalScore() {
  const total = hiddenWordIndices.length * 10;
  const pct = total > 0 ? Math.round((score / total) * 100) : 0;
  const emoji = pct >= 80 ? 'üèÜ' : pct >= 50 ? 'üëè' : 'üòÖ';

  document.getElementById('subtitleText').innerHTML =
    `<span class="word" style="color: var(--accent);">${emoji} Termin√© ! Score : ${score}/${total} (${pct}%)</span>`;
}

function resetGame() {
  pause();
  isMuted = false;
  currentWindowIdx = -1;
  score = 0;
  revealedWords = new Set();
  hiddenWordIndices = [];
  lastSubtitleHtml = '';
  lastLineIdx = -1;
  if (currentSong) currentSong._processedLyrics = null;

  video.volume = savedVolume;
  video.currentTime = 0;

  document.getElementById('scoreValue').textContent = '0';
  document.getElementById('progressBar').style.width = '0%';
  document.getElementById('currentTime').textContent = '0:00';
  document.getElementById('btnPlay').innerHTML = '‚ñ∂ Jouer';
  document.getElementById('btnReveal').disabled = true;
  document.getElementById('guessArea').classList.remove('active');
  document.getElementById('guessFeedback').innerHTML = '';
  document.getElementById('cutoffMarkers').innerHTML = '';
  document.getElementById('windowProgress').classList.remove('active');
  document.getElementById('wpComplete').classList.remove('show');
  updateStatus('paused');

  if (currentSong) {
    document.getElementById('subtitleText').innerHTML =
      `<span class="word" style="color: var(--accent);">‚ô™ ${currentSong.title} ‚Äî ${currentSong.artist} ‚ô™</span>`;
  }
}

// ============================================================
// HELPERS
// ============================================================
function updateStatus(type) {
  const pill = document.getElementById('statusPill');
  pill.className = 'status-pill ' + type;
  const labels = { playing: '‚ñ∂ En lecture', muted: 'üîá Son coup√©', paused: '‚è∏ En attente' };
  pill.innerHTML = labels[type] || '';
}

function formatTime(sec) {
  if (!sec || isNaN(sec)) return '0:00';
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${s.toString().padStart(2, '0')}`;
}

function normalize(str) {
  return str.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
}

function escapeHtml(str) {
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ============================================================
// VOLUME CONTROL
// ============================================================
function setVolume(val) {
  const vol = val / 100;
  video.volume = vol;
  savedVolume = vol;
  document.getElementById('volumePct').textContent = `${Math.round(val)}%`;
  updateVolIcon(vol);
}

function toggleMuteManual() {
  if (video.volume > 0) {
    savedVolume = video.volume;
    video.volume = 0;
    document.getElementById('volumeSlider').value = 0;
    document.getElementById('volumePct').textContent = '0%';
  } else {
    video.volume = savedVolume || 0.8;
    document.getElementById('volumeSlider').value = Math.round(video.volume * 100);
    document.getElementById('volumePct').textContent = `${Math.round(video.volume * 100)}%`;
  }
  updateVolIcon(video.volume);
}

function updateVolIcon(vol) {
  const icon = document.getElementById('volIcon');
  if (vol === 0) icon.textContent = 'üîá';
  else if (vol < 0.35) icon.textContent = 'üîà';
  else if (vol < 0.7) icon.textContent = 'üîâ';
  else icon.textContent = 'üîä';
}

// ============================================================
// CUTOFF WINDOW MARKERS
// ============================================================
function renderCutoffMarkers() {
  const container = document.getElementById('cutoffMarkers');
  const infoEl = document.getElementById('cutoffInfo');
  const windows = currentSong.cutoff_windows || [];
  const duration = currentSong.duration || 1;

  // Render markers on progress bar
  container.innerHTML = windows.map(w => {
    const leftPct = (w[0] / duration) * 100;
    const widthPct = ((w[1] - w[0]) / duration) * 100;
    return `<div class="cutoff-window-marker" style="left:${leftPct}%;width:${widthPct}%"></div>`;
  }).join('');

  // Info text
  const windowsStr = windows.map(w => `${formatTime(w[0])}‚Üí${formatTime(w[1])}`).join(' | ');
  infoEl.textContent = `‚úÇ ${windowsStr}`;
}

// Progress bar seeking
document.getElementById('progressContainer').addEventListener('click', (e) => {
  if (!currentSong) return;
  const rect = e.currentTarget.getBoundingClientRect();
  const pct = (e.clientX - rect.left) / rect.width;
  const duration = (video.duration && !isNaN(video.duration)) ? video.duration : (currentSong.duration || 1);
  const newTime = pct * duration;
  if (video.src) video.currentTime = newTime;
});

// ============================================================
// STATE SYNC ‚Üí push state to server for overlay
// ============================================================
function pushState() {
  if (!currentSong || !currentRoom) return;
  const stateData = {
    song_id: currentSong.id,
    song_title: currentSong.title,
    song_artist: currentSong.artist,
    is_playing: !video.paused,
    is_muted: isMuted,
    current_time: getCurrentTime(),
    score: score,
    revealed_words: Array.from(revealedWords),
    window_idx: currentWindowIdx,
    cutoff_windows: currentSong.cutoff_windows || [],
    lyrics: currentSong.lyrics || [],
    video_url: currentSong.video_url || null,
    duration: currentSong.duration || 0,
    subtitle_offset: currentSong.subtitle_offset || 0,
  };

  fetch(`${API}/api/state?room=${encodeURIComponent(currentRoom)}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(stateData),
  }).catch(() => {});
}

// Push state every 200ms
setInterval(pushState, 200);

// ============================================================
// ROOM MANAGEMENT
// ============================================================
function generateRoomCode() {
  const chars = 'abcdefghjkmnpqrstuvwxyz23456789';
  let code = 'room-';
  for (let i = 0; i < 4; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

function joinRoom() {
  const input = document.getElementById('roomInput');
  const error = document.getElementById('roomError');
  const name = input.value.trim().toLowerCase().replace(/[^a-z0-9-]/g, '');

  if (!name || name.length < 2) {
    error.textContent = 'Le nom doit faire au moins 2 caract√®res (lettres, chiffres, tirets)';
    return;
  }

  enterRoom(name);
}

function createRandomRoom() {
  enterRoom(generateRoomCode());
}

function enterRoom(roomId) {
  currentRoom = roomId;

  // Save to localStorage for persistence
  try { localStorage.setItem('karaoke_room', roomId); } catch(e) {}

  // Update UI
  document.getElementById('roomScreen').classList.add('hidden');
  document.getElementById('roomDisplay').textContent = roomId;

  const overlayUrl = `${window.location.origin}/overlay?room=${encodeURIComponent(roomId)}`;
  document.getElementById('overlayUrl').textContent = overlayUrl;

  // Load library
  init();
}

function copyOverlayUrl() {
  if (!currentRoom) return;
  const url = `${window.location.origin}/overlay?room=${encodeURIComponent(currentRoom)}`;
  navigator.clipboard.writeText(url).then(() => {
    const msg = document.getElementById('copyMsg');
    msg.style.opacity = '1';
    setTimeout(() => { msg.style.opacity = '0'; }, 2000);
  }).catch(() => {});
}

// ============================================================
// INIT
// ============================================================
async function init() {
  showLoading(true);
  songs = await fetchSongs();
  renderSongList(songs);
  showLoading(false);

  // Display overlay URL
  if (currentRoom) {
    const overlayUrl = `${window.location.origin}/overlay?room=${encodeURIComponent(currentRoom)}`;
    document.getElementById('overlayUrl').textContent = overlayUrl;
  }
}

// Check for saved room or URL param
(function startup() {
  // Check URL param first (e.g. /?room=wilfried)
  const urlParams = new URLSearchParams(window.location.search);
  const urlRoom = urlParams.get('room');

  // Then check localStorage
  let savedRoom = null;
  try { savedRoom = localStorage.getItem('karaoke_room'); } catch(e) {}

  if (urlRoom) {
    enterRoom(urlRoom);
  } else if (savedRoom) {
    // Pre-fill and auto-join saved room
    enterRoom(savedRoom);
  }
  // Otherwise the room screen stays visible
})();
</script>
</body>
</html>
